{"title":"Filogenia_EvoMolecular.github.io","markdown":{"yaml":{"title":"Filogenia_EvoMolecular.github.io","author":"Mayra Herrera Pacheco","bibliography":"references.bib","csl":"apa.csl"},"headingText":"Objetivo","containsRefs":true,"markdown":"\n\n\nEste taller busca generar un flujo de trabajo reproducible y extensible para alinear secuencias y definir el mejor esquema de partición y sus modelos asociados.\n\n-   Los archivos resultante de los análisis pueden ser visualizados y descargados en el siguiente repositorio, así como el scrip de Quarto: [Repositorio Filogenia_EvoMolecular](https://github.com/mayalehpa/Filogenia_EvoMolecular)\n\n-   Cada Rutina cuenta con la interpretación de resultados.\n\n# 1. Rutinas para alinear con al menos dos ajustes de parámetros\n\nLas lineas de código están para ejecutarse directamente en la terminal.\n\n## 1.1 Primer ajuste: Párametros predeterminados\n\n-   En tu terminal ve al directorio donde se alejan los archivos .fasta\n\n-   Ve a tu terminal de WSL y ejecuta el siguiente código:\n\n``` bash\n#COI\nmafft --auto coi.fasta > coi.aln.fasta\n\n#16s\nmafft --auto 16s.fasta > 16s.aln.fasta\n```\n\n## 1.2 Segundo ajuste: Párametros modificados\n\n*--maxiterate 1000:* establece el número máximo de iteraciones en 1000\n\n*--localpair:* secuencias por debajo de 200\n\n*--Gap open penalty:* de 1.53\n\n-   Para los párametros modificados usaré maxiterate 1000, localpair y un GAP de 1.53\n\n``` bash\nmafft --maxiterate 1000 --localpair --op 1.53 coi.fasta > coi_custom.aln.fasta\n\nmafft --maxiterate 1000 --localpair --op 1.53 16s.fasta > 16s_custom.aln.fasta\n```\n\n## 1.3 Interpretación de los resultados\n\nPara comparar las alineaciones, puedes usar herramientas como `diff` para ver las diferencias entre los archivos de alineación:\n\n``` bash\n#COI\ndiff coi.aln.fasta coi_custom.aln.fasta > coi_diff.txt\n\n#16s\ndiff 16s.aln.fasta 16s_custom.aln.fasta > 16s_diff.txt\n```\n\nPara mostrar las diferencias ejecuta el siguiente comando\n\n``` bash\ncat coi_diff.txt\n\ncat 16s_diff.txt\n```\n\nAl comparar los archivos generados tras ambos alineamientos de secuencias, observé que tenían el mismo contenido y un tamaño de 0 KB, lo que indica la ausencia de diferencias. Esto podría deberse a que el archivo coi.fasta no contiene suficiente variabilidad entre las secuencias, limitando el impacto de los parámetros personalizados. Esto ocurrio tanto para el análisis con COI y 16s.\n\n## 1.4 Alineamientos Múltiples\n\nPara evitar alinear cada archivo individualmente, podemos usar una línea de comando que alinee automáticamente múltiples regiones ubicadas en una misma carpeta.\n\n### 1.4.1 Creación de la carpeta\n\n-   Crea un nuevo directorio: vamos a crear un directorio dentro de la carpeta fasta_files para almacenar los outputs alineados. En este caso se llamara \"Aline_multiples\".\n\n``` bash\nmkdir -p Aline_multiples\n```\n\n### 1.4.2 Código para alineamiento múltiple\n\n-   Ejecuta el siguiente código para alineamiento múltiple, recuerda estar ubicado en la carpeta \"fasta_files\", alineara todos los archivos que se encuentren dentro de la carpeta con .fasta\n\n``` bash\nfor file in *.fasta; do\n  base_name=\"${file%.fasta}\"\n  mafft --auto \"$file\" > \"Aline_multiples/${base_name}.aln.fasta\"\ndone\n```\n\n**Nota:** la linea de mafft se pueden usar con párametros ajustados.\n\n# 2. Rutina con estimación de modelos utilizando Model Finder\n\nPara poder utilizar Model Finder debemos previamente instalar Iqtree2 en nuestra terminal.\n\n## 2.1 Ejecutar ModelFinder para seleccionar el mejor modelo\n\n-   Crear una carpeta para guardar los resultados\n\n``` bash\nmkdir -p Resultados_iqtree_modelfinder\n```\n\n### 2.1.1 coi.aln.fasta\n\nEl siguiente comando ejecutará IQ-TREE usando Model Finder para determinar el mejor modelo.\n\n``` bash\niqtree2 -s coi.aln.fasta -m MF -redo -pre Coi_iqtree_modelfinder\n```\n\n`iqtree2` Es como se llama a la última versión de Iqtree.\n\n`-redo` Esta opción indica a IQ-TREE que reemplace cualquier resultado anterior si ya existe un archivo de salida con el mismo nombre.\n\n`MFP` Si agregamos P a MF + Indicar el Bootstrap sería para crear un árbol, en este caso solo queremos observar la selección del mejor modelo.\n\n### 2.1.2 16s.aln.fasta\n\n``` bash\niqtree2 -s 16s.aln.fasta -m MF -redo -pre 16s_iqtree_modelfinder\n```\n\n## 2.2 Mostrar el mejor modelo\n\n### 2.2.1 coi.aln.fasta\n\nCon la siguiente línea de comando podemos observar cual fue el mejor modelo:\n\n``` bash\ngrep \"Best-fit model\" Coi_iqtree_modelfinder.iqtree\n```\n\n### 2.2.2 16s.aln.fasta\n\n``` bash\ngrep \"Best-fit model\" 16s_iqtree_modelfinder.iqtree\n```\n\n## 2.3 Análisis de los Resultados\n\n-   El análisis del gen COI con ModelFinder seleccionó el modelo **HKY+F+G4** como el más adecuado según el criterio de información bayesiano (BIC). El modelo HKY es un modelo de sustitución de nucleótidos que permite diferentes tasas de transición y transversión y considera las frecuencias de las bases [@hasegawa1985]. Es una extensión del modelo Kimura 2-parameter (K80). Este modelo es útil para la evolución de secuencias de ADN donde las transiciones son más frecuentes que las transversiones [@thephyl2009].\n\n-   El análisis del gen **16S** con ModelFinder seleccionó el modelo **TIM2+F+G4** como el más adecuado según el criterio de información bayesiano (BIC). Este modelo utiliza la matriz **TIM2** (Transitional model 2), que permite diferentes tasas de sustitución entre transiciones y transversiones[@iq-tree2024], lo cual es especialmente útil para genes como el 16S donde estas variaciones son comunes. La opción **+F** incorpora las frecuencias observadas de nucleótidos, mejorando así la precisión del modelo al considerar la composición real de bases en el alineamiento. Además, la inclusión de la corrección **+G4** introduce heterogeneidad en las tasas de evolución a través de cuatro categorías gamma, permitiendo al modelo capturar variaciones en la velocidad de cambio entre diferentes sitios del gen 16S.\n\n# 3. Rutina con estimación de modelos utilizando Partition Finder\n\n--\\> Para poder ejecutar Partition Finder debemos instalar Python 2.7.10 o superior (no 3.x)\n\n--\\> Para evitar conflicto con las librerias instalaremos Anaconda[@anacondasoftwaredistribution2016] en la terminal y posteriormente realizaremos la instalación de Python 2.7.18. En este paso es bueno utilizar la terminal nativa de Linux ya que si se instala desde el usuario de windows hay conflictos.\n\n## 3.1 Instalaciones necesarias\n\n### 3.1.1 Instalación de Anaconda\n\nEn este caso descargare desde su página el [instalador](https://repo.anaconda.com/archive/) y lo ejecutare desde una terminal nativa de linux.\n\n``` bash\ncd Descargas\nbash ./Anaconda3-2024.06-1-Linux-x86_64.sh\nexport PATH=\"/home/may/anaconda/bin:$PATH\"\n```\n\n`may` hace referencia al usuario que tengo en linux, debes modificarlo de acuerdo a tu usuario.\n\n### 3.1.2 Crea un entorno en Anaconda para poder instalar Python 2.7.18\n\nEsto es un paso importante ya que nos ayudara a realizar el análisis con PartitionFinder.\n\n``` bash\nconda create -n py27 python=2.7.18\n\n## Activar el entorno\n\nconda activate py27\n\n## Verifica la versión de python\n\npython --version\n\n## Si quieres desactivar el entorno\n\nconda deactivate\n```\n\n`py27` hace referencia al nombre que le quise colocar al entorno\n\n### 3.1.3 Instala PartitionFinder\n\nAhora que estamos en el entorno de python 2.7.18, y con las librerias necesarias podremos instalar y ejecutar PartitionFinder para nuestro análisis.\n\n3.1 Descarga PartitionFinder en su [página principal](https://www.robertlanfear.com/partitionfinder/) el archivo Source code (tar.gz)\n\n3.2 Al descomprimir, aloja la carpeta en bin (sino tienes la carpeta bin, la puedes crear)\n\n3.3 Ve a la terminal y ve hacia el directorio donde esta la carpeta\n\n``` bash\ncd ~/bin/partitionfinder-2.1.1\n```\n\n## 3.2 Ejecuta PartitionFinder\n\nDespués de estar en la carpeta de partitionfinder-2.1.1, ejecuta la siguiente linea de comando:\n\n``` bash\nphyton PartitionFinder.phy\n```\n\n### 3.2.1 Configuración del archivo .cfg\n\n-   Para poder hacer el análisis de selección de modelo primero debemos configurar el archivo .cfg\n\n-   Configurar el archivo partition_finder.cfg:\n\n``` bash\nvim partition_finder.cfg\n```\n\nEl comando anterior es para crear el archivo de configuración con el **editor vim**, procederemos a ingresar la siguiente información: (las opciones se modifican de acuerdo a nuestros datos)\n\n**Importante:** Los archivos que admite PartitionFinder es .nex o .phy. En nuestro caso usaremos .phy\n\n``` bash\n## Ejemplo con el archivo 16s_iqtree_modelfinder.uniqueseq.phy\n\n## ALIGNMENT FILE ##\nalignment = 16s_iqtree_modelfinder.uniqueseq.phy;\n\n## BRANCHLENGTHS: linked | unlinked ##\nbranchlengths = linked;\n\n## MODELS OF EVOLUTION: all | allx | mrbayes | beast | gamma | gammai | <list> ##\nmodels = all;\n\n# MODEL SELECCTION: AIC | AICc | BIC #\nmodel_selection = BIC;\n\n## DATA BLOCKS: see manual for how to define ##\n[data_blocks]\nall = 1-905;\n\n## SCHEMES, search: all | user | greedy | rcluster | rclusterf | kmeans ##\n[schemes]\nsearch = all;\n```\n\nPara profundizar sobre la ejecución y análisis en PartitionFinder puedes ver el [tutorial](https://www.robertlanfear.com/partitionfinder/tutorial/) en la página principal.\n\n### 3.2.2 Selección del modelo\n\nPara realizar el análisis debemos tener el archivo .phy y el archivo .cfg en la misma carpeta que el ejecutable (PartitionFinder.py). Luego ejecuta el siguiente código:\n\n**NOTA:** El programa solo reconoce un archivo de configuración bajo el nombre de \"partition_finder.cfg\". Por ello debemos configurarlo para cada archivo de .phy (ver punto [3.2.1 Configuración del archivo .cfg])\n\n``` bash\npython PartitionFinder.py partition_finder.cfg\n```\n\nPara visualizar los resultados después de este análisis en la carpeta `analysis` se guarda un archivo .txt llamado best_scheme. Para poder guardar el resultado podemos renombrarlo, así no se va a sobreescribir.\n\n#### Comando para renombrar el archivo\n\n``` bash\nmv best_scheme.txt best_scheme_coi.txt\n```\n\n-   Luego modificaremos el archivo de configuración para 16s y ejecutaremos el primer código. Posteriormente renombramos el archivo .txt para no confundirnos.\n\n-   En caso de estar presentando dificultades con la obtención de resultados podemos usar el siguiente comando para forzar.\n\n``` bash\npython PartitionFinder.py partition_finder.cfg --force-restart\n```\n\n## 3.3 Análisis de Resultados\n\n### 3.3.1 Resultados para COI\n\nEl análisis con PartitionFinder muestra que el modelo seleccionado fue HKY+G [@hasegawa1985; @iq-tree2024]. La selección del modelo se basó en el criterio de información bayesiano (BIC), que arrojó un valor de 4944.97, indicando una buena adecuación del modelo en relación con el número de parámetros (100).\n\n### 3.3.2 Resultados para 16S\n\nEl análisis con PartitionFinder muestra que el modelo seleccionado fue GTR+G. Abarcando un total de 905 sitios con 88 parámetros.\n\n# 4. Rutina con estimación de modelos utilizando Mixture Models\n\n## 4.1 MixtureFinder\n\nPara crear la rutina utilizando [Mixture Models](http://www.iqtree.org/doc/Complex-Models), usaremos la herramienta MixtureFinder [^1] que se encuentra en Iqtree2 para saber que modelos podemos usar [@ren].\n\n[^1]: **MixtureFinder:** Es una herramienta específica disponible en IQ-TREE (a partir de la versión 2.3.1) que ayuda a seleccionar el número óptimo de clases y el modelo de sustitución para cada clase dentro de un modelo de mezcla. *MixtureFinder* automatiza el proceso de selección de estos modelos de mezcla, ajustando el número de clases y evaluando el mejor modelo en función de criterios como BIC, AIC o pruebas de verosimilitud.\n\n1.  Es importante que los archivos estén en formato FASTA o PHYLIP.\n\n2.  Crea una nueva carpeta para guardar los resultados, recuerda agregar los archivos alineados FASTA o PHYLIP.\n\n``` bash\nmkdir -p MixtureFinder_analysis \n```\n\n3.  Ejecuta el comando\n\n``` bash\n#16s\niqtree2 -s 16s_iqtree_modelfinder.uniqueseq.phy -m MIX+MF \n\n#COI\niqtree2 -s Coi_iqtree_modelfinder.uniqueseq.phy -m MIX+MF \n```\n\n4.  Comando para saber cuál fue el mejor modelo\n\nEntre todos los documentos generados al correr el análisis encontramos el archivo .log, el cual contiene los resultados y podremos observar el \"Best-fit model\". Pero empleando el siguiente comando en la terminal podremos obtenerlo de forma rápida:\n\n``` bash\n#16s\ncat 16s_iqtree_modelfinder.uniqueseq.phy.log | grep \"Best-fit model:\" \n\n#COI\ncat Coi_iqtree_modelfinder.uniqueseq.phy.log | grep \"Best-fit model:\" \n```\n\nEn este caso el mejor modelo de mezcla encontrado por el programa para 16s usando BIC fue: MIX{TIM2+FO,JC+FO}+G4\n\n-   Dos modelos de sustitución (TIM2+FO y JC+FO).\n-   Gamma rate heterogeneity con cuatro categorías (+G4)\n\nPara COI el mejor modelo de mezcla encontra usando BIC fue: MIX{HKY+FO,JC+FO}+G4\n\n## 4.2 Analizando el mejor modelo escogido por MixtureFinder\n\nAhora vamos a realizar el análisis con el modelo seleccionado en MixtureFinder\n\n-   Ejecuta el siguiente comando:\n\n``` bash\n#16s\niqtree2 -s 16s_iqtree_modelfinder.uniqueseq.phy -m \"MIX{TIM2+FO,JC+FO}+G4\" -redo\n\n#COI\niqtree2 -s Coi_iqtree_modelfinder.uniqueseq.phy -m \"MIX{HKY+FO,JC+FO}+G4\" -redo\n```\n\n`redo` Me permite sobreescribir en el archivo que ya se habia generado del análisis anterior\n\n## 4.3 Análisis de resultados\n\nPara la estimación de modelos usando Mixture Models en IQ-TREE, utilicé MixtureFinder, que evaluó diferentes modelos de sustitución para encontrar el ajuste óptimo según el criterio BIC. El análisis concluyó que el mejor modelo fue MIX{TIM2+FO,JC+FO}+G4 para el alineamiento de 16s. Este modelo combina los modelos de sustitución TIM2+FO y JC+FO, además de incorporar la heterogeneidad de tasas de evolución entre sitios con el modelo Gamma (+G4), el cual permite cuatro categorías de tasas. La selección de este modelo mixto indica que, en lugar de asignar un solo modelo a todos los sitios de la secuencia, se permite que diferentes sitios tengan probabilidades de pertenecer a distintas categorías de modelos de sustitución, lo que mejora la precisión de la inferencia al reflejar la variabilidad evolutiva en el conjunto de datos. Esta flexibilidad es esencial en análisis complejos, ya que incrementa la capacidad del modelo para capturar patrones evolutivos específicos, haciendo que el árbol resultante sea más robusto y adecuado para las características observadas en las secuencias.\n\nEl análisis del gen COI utilizando MixtureFinder identificó el modelo óptimo como MIX{HKY+FO, JC+FO} + G4. Este modelo es un modelo mixto que emplea dos componentes de sustitución, HKY+FO (un modelo que considera frecuencias observadas de bases y diferentes tasas de transición y transversión) y JC+FO (modelo de Jukes-Cantor con frecuencias observadas) [@jukes1969], además de una corrección de heterogeneidad de tasas de evolución gamma en cuatro categorías (+G4). La combinación de estos componentes permite que cada sitio en la secuencia tenga una probabilidad asignada de pertenecer a uno de los dos modelos de sustitución, lo cual refleja adecuadamente la variabilidad evolutiva en el gen COI.\n\n# 5. Resumen y Análisis final\n\nA continuación se mostrara un resumen en forma de tabla, para visualizar el mejor modelo escogido por cada programa para cada gen.\n\n| Gen | Programa        | Mejor Modelo          | Criterio |\n|-----|-----------------|-----------------------|----------|\n| COI | ModelFinder     | HKY+F+G4              | BIC      |\n| 16s | ModelFinder     | TIM2+F+G4             | BIC      |\n| COI | PartitionFinder | HKY+G                 | BIC      |\n| 16s | PartitionFinder | GTR+G                 | BIC      |\n| COI | MixtureFinder   | MIX{HKY+FO,JC+FO}+G4  | BIC      |\n| 16s | MixtureFinder   | MIX{TIM2+FO,JC+FO}+G4 | BIC      |\n\n: Tabla 1. Resumen de los programas y selección del modelo para cada Gen analizado\n\nEl análisis comparativo de los modelos evolutivos seleccionados para los genes COI y 16S, realizado a través de diferentes programas, muestra la importancia de considerar múltiples enfoques en la elección del modelo adecuado. Por ejemplo, en la selección del modelo HKY para el gen COI, los tres programas utilizados lo escogieron como uno de los mejores modelos. De esta manera, el uso de múltiples herramientas no solo reafirma la elección de un modelo, sino que también permite explorar diferentes estrategias, como modelos mixtos y particionamiento de datos. Esta diversidad en los enfoques proporciona una comprensión más robusta de los modelos evolutivos, lo que me permitirá obtener un análisis más preciso.\n\n# 6. Referencias Bibliográficas\n\n::: {#refs}\n:::\n","srcMarkdownNoYaml":"\n\n# Objetivo\n\nEste taller busca generar un flujo de trabajo reproducible y extensible para alinear secuencias y definir el mejor esquema de partición y sus modelos asociados.\n\n-   Los archivos resultante de los análisis pueden ser visualizados y descargados en el siguiente repositorio, así como el scrip de Quarto: [Repositorio Filogenia_EvoMolecular](https://github.com/mayalehpa/Filogenia_EvoMolecular)\n\n-   Cada Rutina cuenta con la interpretación de resultados.\n\n# 1. Rutinas para alinear con al menos dos ajustes de parámetros\n\nLas lineas de código están para ejecutarse directamente en la terminal.\n\n## 1.1 Primer ajuste: Párametros predeterminados\n\n-   En tu terminal ve al directorio donde se alejan los archivos .fasta\n\n-   Ve a tu terminal de WSL y ejecuta el siguiente código:\n\n``` bash\n#COI\nmafft --auto coi.fasta > coi.aln.fasta\n\n#16s\nmafft --auto 16s.fasta > 16s.aln.fasta\n```\n\n## 1.2 Segundo ajuste: Párametros modificados\n\n*--maxiterate 1000:* establece el número máximo de iteraciones en 1000\n\n*--localpair:* secuencias por debajo de 200\n\n*--Gap open penalty:* de 1.53\n\n-   Para los párametros modificados usaré maxiterate 1000, localpair y un GAP de 1.53\n\n``` bash\nmafft --maxiterate 1000 --localpair --op 1.53 coi.fasta > coi_custom.aln.fasta\n\nmafft --maxiterate 1000 --localpair --op 1.53 16s.fasta > 16s_custom.aln.fasta\n```\n\n## 1.3 Interpretación de los resultados\n\nPara comparar las alineaciones, puedes usar herramientas como `diff` para ver las diferencias entre los archivos de alineación:\n\n``` bash\n#COI\ndiff coi.aln.fasta coi_custom.aln.fasta > coi_diff.txt\n\n#16s\ndiff 16s.aln.fasta 16s_custom.aln.fasta > 16s_diff.txt\n```\n\nPara mostrar las diferencias ejecuta el siguiente comando\n\n``` bash\ncat coi_diff.txt\n\ncat 16s_diff.txt\n```\n\nAl comparar los archivos generados tras ambos alineamientos de secuencias, observé que tenían el mismo contenido y un tamaño de 0 KB, lo que indica la ausencia de diferencias. Esto podría deberse a que el archivo coi.fasta no contiene suficiente variabilidad entre las secuencias, limitando el impacto de los parámetros personalizados. Esto ocurrio tanto para el análisis con COI y 16s.\n\n## 1.4 Alineamientos Múltiples\n\nPara evitar alinear cada archivo individualmente, podemos usar una línea de comando que alinee automáticamente múltiples regiones ubicadas en una misma carpeta.\n\n### 1.4.1 Creación de la carpeta\n\n-   Crea un nuevo directorio: vamos a crear un directorio dentro de la carpeta fasta_files para almacenar los outputs alineados. En este caso se llamara \"Aline_multiples\".\n\n``` bash\nmkdir -p Aline_multiples\n```\n\n### 1.4.2 Código para alineamiento múltiple\n\n-   Ejecuta el siguiente código para alineamiento múltiple, recuerda estar ubicado en la carpeta \"fasta_files\", alineara todos los archivos que se encuentren dentro de la carpeta con .fasta\n\n``` bash\nfor file in *.fasta; do\n  base_name=\"${file%.fasta}\"\n  mafft --auto \"$file\" > \"Aline_multiples/${base_name}.aln.fasta\"\ndone\n```\n\n**Nota:** la linea de mafft se pueden usar con párametros ajustados.\n\n# 2. Rutina con estimación de modelos utilizando Model Finder\n\nPara poder utilizar Model Finder debemos previamente instalar Iqtree2 en nuestra terminal.\n\n## 2.1 Ejecutar ModelFinder para seleccionar el mejor modelo\n\n-   Crear una carpeta para guardar los resultados\n\n``` bash\nmkdir -p Resultados_iqtree_modelfinder\n```\n\n### 2.1.1 coi.aln.fasta\n\nEl siguiente comando ejecutará IQ-TREE usando Model Finder para determinar el mejor modelo.\n\n``` bash\niqtree2 -s coi.aln.fasta -m MF -redo -pre Coi_iqtree_modelfinder\n```\n\n`iqtree2` Es como se llama a la última versión de Iqtree.\n\n`-redo` Esta opción indica a IQ-TREE que reemplace cualquier resultado anterior si ya existe un archivo de salida con el mismo nombre.\n\n`MFP` Si agregamos P a MF + Indicar el Bootstrap sería para crear un árbol, en este caso solo queremos observar la selección del mejor modelo.\n\n### 2.1.2 16s.aln.fasta\n\n``` bash\niqtree2 -s 16s.aln.fasta -m MF -redo -pre 16s_iqtree_modelfinder\n```\n\n## 2.2 Mostrar el mejor modelo\n\n### 2.2.1 coi.aln.fasta\n\nCon la siguiente línea de comando podemos observar cual fue el mejor modelo:\n\n``` bash\ngrep \"Best-fit model\" Coi_iqtree_modelfinder.iqtree\n```\n\n### 2.2.2 16s.aln.fasta\n\n``` bash\ngrep \"Best-fit model\" 16s_iqtree_modelfinder.iqtree\n```\n\n## 2.3 Análisis de los Resultados\n\n-   El análisis del gen COI con ModelFinder seleccionó el modelo **HKY+F+G4** como el más adecuado según el criterio de información bayesiano (BIC). El modelo HKY es un modelo de sustitución de nucleótidos que permite diferentes tasas de transición y transversión y considera las frecuencias de las bases [@hasegawa1985]. Es una extensión del modelo Kimura 2-parameter (K80). Este modelo es útil para la evolución de secuencias de ADN donde las transiciones son más frecuentes que las transversiones [@thephyl2009].\n\n-   El análisis del gen **16S** con ModelFinder seleccionó el modelo **TIM2+F+G4** como el más adecuado según el criterio de información bayesiano (BIC). Este modelo utiliza la matriz **TIM2** (Transitional model 2), que permite diferentes tasas de sustitución entre transiciones y transversiones[@iq-tree2024], lo cual es especialmente útil para genes como el 16S donde estas variaciones son comunes. La opción **+F** incorpora las frecuencias observadas de nucleótidos, mejorando así la precisión del modelo al considerar la composición real de bases en el alineamiento. Además, la inclusión de la corrección **+G4** introduce heterogeneidad en las tasas de evolución a través de cuatro categorías gamma, permitiendo al modelo capturar variaciones en la velocidad de cambio entre diferentes sitios del gen 16S.\n\n# 3. Rutina con estimación de modelos utilizando Partition Finder\n\n--\\> Para poder ejecutar Partition Finder debemos instalar Python 2.7.10 o superior (no 3.x)\n\n--\\> Para evitar conflicto con las librerias instalaremos Anaconda[@anacondasoftwaredistribution2016] en la terminal y posteriormente realizaremos la instalación de Python 2.7.18. En este paso es bueno utilizar la terminal nativa de Linux ya que si se instala desde el usuario de windows hay conflictos.\n\n## 3.1 Instalaciones necesarias\n\n### 3.1.1 Instalación de Anaconda\n\nEn este caso descargare desde su página el [instalador](https://repo.anaconda.com/archive/) y lo ejecutare desde una terminal nativa de linux.\n\n``` bash\ncd Descargas\nbash ./Anaconda3-2024.06-1-Linux-x86_64.sh\nexport PATH=\"/home/may/anaconda/bin:$PATH\"\n```\n\n`may` hace referencia al usuario que tengo en linux, debes modificarlo de acuerdo a tu usuario.\n\n### 3.1.2 Crea un entorno en Anaconda para poder instalar Python 2.7.18\n\nEsto es un paso importante ya que nos ayudara a realizar el análisis con PartitionFinder.\n\n``` bash\nconda create -n py27 python=2.7.18\n\n## Activar el entorno\n\nconda activate py27\n\n## Verifica la versión de python\n\npython --version\n\n## Si quieres desactivar el entorno\n\nconda deactivate\n```\n\n`py27` hace referencia al nombre que le quise colocar al entorno\n\n### 3.1.3 Instala PartitionFinder\n\nAhora que estamos en el entorno de python 2.7.18, y con las librerias necesarias podremos instalar y ejecutar PartitionFinder para nuestro análisis.\n\n3.1 Descarga PartitionFinder en su [página principal](https://www.robertlanfear.com/partitionfinder/) el archivo Source code (tar.gz)\n\n3.2 Al descomprimir, aloja la carpeta en bin (sino tienes la carpeta bin, la puedes crear)\n\n3.3 Ve a la terminal y ve hacia el directorio donde esta la carpeta\n\n``` bash\ncd ~/bin/partitionfinder-2.1.1\n```\n\n## 3.2 Ejecuta PartitionFinder\n\nDespués de estar en la carpeta de partitionfinder-2.1.1, ejecuta la siguiente linea de comando:\n\n``` bash\nphyton PartitionFinder.phy\n```\n\n### 3.2.1 Configuración del archivo .cfg\n\n-   Para poder hacer el análisis de selección de modelo primero debemos configurar el archivo .cfg\n\n-   Configurar el archivo partition_finder.cfg:\n\n``` bash\nvim partition_finder.cfg\n```\n\nEl comando anterior es para crear el archivo de configuración con el **editor vim**, procederemos a ingresar la siguiente información: (las opciones se modifican de acuerdo a nuestros datos)\n\n**Importante:** Los archivos que admite PartitionFinder es .nex o .phy. En nuestro caso usaremos .phy\n\n``` bash\n## Ejemplo con el archivo 16s_iqtree_modelfinder.uniqueseq.phy\n\n## ALIGNMENT FILE ##\nalignment = 16s_iqtree_modelfinder.uniqueseq.phy;\n\n## BRANCHLENGTHS: linked | unlinked ##\nbranchlengths = linked;\n\n## MODELS OF EVOLUTION: all | allx | mrbayes | beast | gamma | gammai | <list> ##\nmodels = all;\n\n# MODEL SELECCTION: AIC | AICc | BIC #\nmodel_selection = BIC;\n\n## DATA BLOCKS: see manual for how to define ##\n[data_blocks]\nall = 1-905;\n\n## SCHEMES, search: all | user | greedy | rcluster | rclusterf | kmeans ##\n[schemes]\nsearch = all;\n```\n\nPara profundizar sobre la ejecución y análisis en PartitionFinder puedes ver el [tutorial](https://www.robertlanfear.com/partitionfinder/tutorial/) en la página principal.\n\n### 3.2.2 Selección del modelo\n\nPara realizar el análisis debemos tener el archivo .phy y el archivo .cfg en la misma carpeta que el ejecutable (PartitionFinder.py). Luego ejecuta el siguiente código:\n\n**NOTA:** El programa solo reconoce un archivo de configuración bajo el nombre de \"partition_finder.cfg\". Por ello debemos configurarlo para cada archivo de .phy (ver punto [3.2.1 Configuración del archivo .cfg])\n\n``` bash\npython PartitionFinder.py partition_finder.cfg\n```\n\nPara visualizar los resultados después de este análisis en la carpeta `analysis` se guarda un archivo .txt llamado best_scheme. Para poder guardar el resultado podemos renombrarlo, así no se va a sobreescribir.\n\n#### Comando para renombrar el archivo\n\n``` bash\nmv best_scheme.txt best_scheme_coi.txt\n```\n\n-   Luego modificaremos el archivo de configuración para 16s y ejecutaremos el primer código. Posteriormente renombramos el archivo .txt para no confundirnos.\n\n-   En caso de estar presentando dificultades con la obtención de resultados podemos usar el siguiente comando para forzar.\n\n``` bash\npython PartitionFinder.py partition_finder.cfg --force-restart\n```\n\n## 3.3 Análisis de Resultados\n\n### 3.3.1 Resultados para COI\n\nEl análisis con PartitionFinder muestra que el modelo seleccionado fue HKY+G [@hasegawa1985; @iq-tree2024]. La selección del modelo se basó en el criterio de información bayesiano (BIC), que arrojó un valor de 4944.97, indicando una buena adecuación del modelo en relación con el número de parámetros (100).\n\n### 3.3.2 Resultados para 16S\n\nEl análisis con PartitionFinder muestra que el modelo seleccionado fue GTR+G. Abarcando un total de 905 sitios con 88 parámetros.\n\n# 4. Rutina con estimación de modelos utilizando Mixture Models\n\n## 4.1 MixtureFinder\n\nPara crear la rutina utilizando [Mixture Models](http://www.iqtree.org/doc/Complex-Models), usaremos la herramienta MixtureFinder [^1] que se encuentra en Iqtree2 para saber que modelos podemos usar [@ren].\n\n[^1]: **MixtureFinder:** Es una herramienta específica disponible en IQ-TREE (a partir de la versión 2.3.1) que ayuda a seleccionar el número óptimo de clases y el modelo de sustitución para cada clase dentro de un modelo de mezcla. *MixtureFinder* automatiza el proceso de selección de estos modelos de mezcla, ajustando el número de clases y evaluando el mejor modelo en función de criterios como BIC, AIC o pruebas de verosimilitud.\n\n1.  Es importante que los archivos estén en formato FASTA o PHYLIP.\n\n2.  Crea una nueva carpeta para guardar los resultados, recuerda agregar los archivos alineados FASTA o PHYLIP.\n\n``` bash\nmkdir -p MixtureFinder_analysis \n```\n\n3.  Ejecuta el comando\n\n``` bash\n#16s\niqtree2 -s 16s_iqtree_modelfinder.uniqueseq.phy -m MIX+MF \n\n#COI\niqtree2 -s Coi_iqtree_modelfinder.uniqueseq.phy -m MIX+MF \n```\n\n4.  Comando para saber cuál fue el mejor modelo\n\nEntre todos los documentos generados al correr el análisis encontramos el archivo .log, el cual contiene los resultados y podremos observar el \"Best-fit model\". Pero empleando el siguiente comando en la terminal podremos obtenerlo de forma rápida:\n\n``` bash\n#16s\ncat 16s_iqtree_modelfinder.uniqueseq.phy.log | grep \"Best-fit model:\" \n\n#COI\ncat Coi_iqtree_modelfinder.uniqueseq.phy.log | grep \"Best-fit model:\" \n```\n\nEn este caso el mejor modelo de mezcla encontrado por el programa para 16s usando BIC fue: MIX{TIM2+FO,JC+FO}+G4\n\n-   Dos modelos de sustitución (TIM2+FO y JC+FO).\n-   Gamma rate heterogeneity con cuatro categorías (+G4)\n\nPara COI el mejor modelo de mezcla encontra usando BIC fue: MIX{HKY+FO,JC+FO}+G4\n\n## 4.2 Analizando el mejor modelo escogido por MixtureFinder\n\nAhora vamos a realizar el análisis con el modelo seleccionado en MixtureFinder\n\n-   Ejecuta el siguiente comando:\n\n``` bash\n#16s\niqtree2 -s 16s_iqtree_modelfinder.uniqueseq.phy -m \"MIX{TIM2+FO,JC+FO}+G4\" -redo\n\n#COI\niqtree2 -s Coi_iqtree_modelfinder.uniqueseq.phy -m \"MIX{HKY+FO,JC+FO}+G4\" -redo\n```\n\n`redo` Me permite sobreescribir en el archivo que ya se habia generado del análisis anterior\n\n## 4.3 Análisis de resultados\n\nPara la estimación de modelos usando Mixture Models en IQ-TREE, utilicé MixtureFinder, que evaluó diferentes modelos de sustitución para encontrar el ajuste óptimo según el criterio BIC. El análisis concluyó que el mejor modelo fue MIX{TIM2+FO,JC+FO}+G4 para el alineamiento de 16s. Este modelo combina los modelos de sustitución TIM2+FO y JC+FO, además de incorporar la heterogeneidad de tasas de evolución entre sitios con el modelo Gamma (+G4), el cual permite cuatro categorías de tasas. La selección de este modelo mixto indica que, en lugar de asignar un solo modelo a todos los sitios de la secuencia, se permite que diferentes sitios tengan probabilidades de pertenecer a distintas categorías de modelos de sustitución, lo que mejora la precisión de la inferencia al reflejar la variabilidad evolutiva en el conjunto de datos. Esta flexibilidad es esencial en análisis complejos, ya que incrementa la capacidad del modelo para capturar patrones evolutivos específicos, haciendo que el árbol resultante sea más robusto y adecuado para las características observadas en las secuencias.\n\nEl análisis del gen COI utilizando MixtureFinder identificó el modelo óptimo como MIX{HKY+FO, JC+FO} + G4. Este modelo es un modelo mixto que emplea dos componentes de sustitución, HKY+FO (un modelo que considera frecuencias observadas de bases y diferentes tasas de transición y transversión) y JC+FO (modelo de Jukes-Cantor con frecuencias observadas) [@jukes1969], además de una corrección de heterogeneidad de tasas de evolución gamma en cuatro categorías (+G4). La combinación de estos componentes permite que cada sitio en la secuencia tenga una probabilidad asignada de pertenecer a uno de los dos modelos de sustitución, lo cual refleja adecuadamente la variabilidad evolutiva en el gen COI.\n\n# 5. Resumen y Análisis final\n\nA continuación se mostrara un resumen en forma de tabla, para visualizar el mejor modelo escogido por cada programa para cada gen.\n\n| Gen | Programa        | Mejor Modelo          | Criterio |\n|-----|-----------------|-----------------------|----------|\n| COI | ModelFinder     | HKY+F+G4              | BIC      |\n| 16s | ModelFinder     | TIM2+F+G4             | BIC      |\n| COI | PartitionFinder | HKY+G                 | BIC      |\n| 16s | PartitionFinder | GTR+G                 | BIC      |\n| COI | MixtureFinder   | MIX{HKY+FO,JC+FO}+G4  | BIC      |\n| 16s | MixtureFinder   | MIX{TIM2+FO,JC+FO}+G4 | BIC      |\n\n: Tabla 1. Resumen de los programas y selección del modelo para cada Gen analizado\n\nEl análisis comparativo de los modelos evolutivos seleccionados para los genes COI y 16S, realizado a través de diferentes programas, muestra la importancia de considerar múltiples enfoques en la elección del modelo adecuado. Por ejemplo, en la selección del modelo HKY para el gen COI, los tres programas utilizados lo escogieron como uno de los mejores modelos. De esta manera, el uso de múltiples herramientas no solo reafirma la elección de un modelo, sino que también permite explorar diferentes estrategias, como modelos mixtos y particionamiento de datos. Esta diversidad en los enfoques proporciona una comprensión más robusta de los modelos evolutivos, lo que me permitirá obtener un análisis más preciso.\n\n# 6. Referencias Bibliográficas\n\n::: {#refs}\n:::\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["styles.css"],"toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","editor":"visual","theme":"cosmo","title":"Filogenia_EvoMolecular.github.io","author":"Mayra Herrera Pacheco","bibliography":["references.bib"],"csl":"apa.csl"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}